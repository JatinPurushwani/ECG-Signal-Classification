# ecg_pipeline.py
# End-to-end ECG feature classification: preprocess → balance → split/scale → train → evaluate → export

import os
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.utils import resample
from sklearn.preprocessing import LabelEncoder, StandardScaler, label_binarize
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import (
    accuracy_score,
    precision_recall_fscore_support,
    confusion_matrix,
    roc_curve,
    auc,
)

# ----------------------------
# CONFIG
# ----------------------------
DATA_PATH = r"D:\ML_Projects\ECG_Minor\data\ecg_data.csv"            # input CSV (original)
BALANCED_PATH = r"D:\ML_Projects\ECG_Minor\data\ecg_data_balanced.csv" # output CSV (balanced)
REPORTS_DIR = r"D:\ML_Projects\ECG_Minor\reports\figures"              # figures output dir
RESULTS_CSV = r"D:\ML_Projects\ECG_Minor\reports\model_comparison.csv" # results table
RANDOM_STATE = 42
TEST_SIZE = 0.2

os.makedirs(REPORTS_DIR, exist_ok=True)

# ----------------------------
# LOAD
# ----------------------------
df = pd.read_csv(DATA_PATH)

# ----------------------------
# CLEAN + ENCODE
# ----------------------------
df = df.fillna(df.median(numeric_only=True))

if "label" not in df.columns:
    raise ValueError("Expected a 'label' column in the dataset.")

le = LabelEncoder()
df["label_encoded"] = le.fit_transform(df["label"])

# ----------------------------
# BALANCE (to minority class size)
# ----------------------------
balanced_df = pd.DataFrame()
class_counts = df["label_encoded"].value_counts()
target_n = class_counts.min()

for cid in class_counts.index:
    subset = df[df["label_encoded"] == cid]
    if len(subset) > target_n:
        subset = resample(subset, replace=False, n_samples=target_n, random_state=RANDOM_STATE)
    else:
        subset = resample(subset, replace=True, n_samples=target_n, random_state=RANDOM_STATE)
    balanced_df = pd.concat([balanced_df, subset], ignore_index=True)

balanced_df.to_csv(BALANCED_PATH, index=False)

# ----------------------------
# SPLIT + SCALE
# ----------------------------
X = balanced_df.drop(columns=["label", "label_encoded"], errors="ignore")
y = balanced_df["label_encoded"]

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=TEST_SIZE, random_state=RANDOM_STATE, stratify=y
)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# ----------------------------
# MODELS
# ----------------------------
models = {
    "DecisionTree": DecisionTreeClassifier(random_state=RANDOM_STATE),
    "RandomForest": RandomForestClassifier(n_estimators=300, random_state=RANDOM_STATE, n_jobs=-1),
}

# Optional XGBoost
try:
    from xgboost import XGBClassifier
    models["XGBoost"] = XGBClassifier(
        max_depth=6, n_estimators=400, learning_rate=0.05,
        subsample=0.9, colsample_bytree=0.8, objective="multi:softprob",
        random_state=RANDOM_STATE, n_jobs=-1
    )
except Exception:
    pass  # xgboost not installed; skip

# ----------------------------
# TRAIN + EVALUATE
# ----------------------------
rows = []
for name, m in models.items():
    m.fit(X_train_scaled, y_train)
    y_pred = m.predict(X_test_scaled)
    acc = accuracy_score(y_test, y_pred)
    prec, rec, f1, _ = precision_recall_fscore_support(
        y_test, y_pred, average="weighted", zero_division=0
    )
    rows.append({"Model": name, "Accuracy": acc, "Precision": prec, "Recall": rec, "F1": f1})

results_df = pd.DataFrame(rows).sort_values("F1", ascending=False)
results_df.to_csv(RESULTS_CSV, index=False)
print(results_df)

# ----------------------------
# BEST MODEL → CONFUSION MATRIX
# ----------------------------
best_name = results_df.iloc[0]["Model"]
best_model = models[best_name]
y_pred = best_model.predict(X_test_scaled)

cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(6, 5))
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.title(f"Confusion Matrix — {best_name}")
plt.xlabel("Predicted")
plt.ylabel("True")
plt.tight_layout()
plt.savefig(os.path.join(REPORTS_DIR, "confusion_matrix.png"), dpi=150)
plt.close()

# ----------------------------
# FEATURE IMPORTANCE (if available)
# ----------------------------
if hasattr(best_model, "feature_importances_"):
    importances = best_model.feature_importances_
    idx = np.argsort(importances)[-min(20, len(importances)):]
    plt.figure(figsize=(8, 6))
    plt.barh(range(len(idx)), importances[idx])
    plt.yticks(range(len(idx)), X.columns[idx])
    plt.title(f"Top Features — {best_name}")
    plt.tight_layout()
    plt.savefig(os.path.join(REPORTS_DIR, "feature_importance.png"), dpi=150)
    plt.close()

# ----------------------------
# MULTICLASS ROC (needs predict_proba)
# ----------------------------
if hasattr(best_model, "predict_proba"):
    n_classes = y_train.nunique()
    classes_sorted = sorted(y_train.unique())
    y_test_bin = label_binarize(y_test, classes=classes_sorted)
    y_proba = best_model.predict_proba(X_test_scaled)

    fpr, tpr, roc_auc = {}, {}, {}
    for i in range(n_classes):
        fpr[i], tpr[i], _ = roc_curve(y_test_bin[:, i], y_proba[:, i])
        roc_auc[i] = auc(fpr[i], tpr[i])

    plt.figure(figsize=(8, 6))
    for i in range(n_classes):
        plt.plot(fpr[i], tpr[i], label=f"Class {classes_sorted[i]} AUC={roc_auc[i]:.2f}")
    plt.plot([0, 1], [0, 1], "k--")
    plt.xlabel("False Positive Rate")
    plt.ylabel("True Positive Rate")
    plt.title(f"ROC Curve — {best_name}")
    plt.legend()
    plt.tight_layout()
    plt.savefig(os.path.join(REPORTS_DIR, "roc_multiclass.png"), dpi=150)
    plt.close()

print(f"Balanced data: {BALANCED_PATH}")
print(f"Reports CSV : {RESULTS_CSV}")
print(f"Figures     : {REPORTS_DIR}\\confusion_matrix.png, feature_importance.png, roc_multiclass.png")
